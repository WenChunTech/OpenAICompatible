package openai

import "encoding/json"

// ChatCompletionRequest represents the request body for the OpenAI Chat Completions API.
// Based on documentation from https://platform.openai.com/docs/api-reference/chat/create
type ChatCompletionRequest struct {
	Model               string                  `json:"model"`
	Messages            []ChatCompletionMessage `json:"messages"`
	Audio               *AudioOutputConfig      `json:"audio,omitempty"` // For audio output requests
	FrequencyPenalty    *float64                `json:"frequency_penalty,omitempty"`
	LogitBias           map[string]int          `json:"logit_bias,omitempty"`
	LogProbs            *bool                   `json:"logprobs,omitempty"`
	MaxCompletionTokens *int                    `json:"max_completion_tokens,omitempty"` // Preferred over MaxTokens
	Metadata            map[string]string       `json:"metadata,omitempty"`              // Up to 16 key-value pairs
	Modalities          []string                `json:"modalities,omitempty"`            // e.g., ["text"], ["text", "audio"]
	N                   *int                    `json:"n,omitempty"`
	ParallelToolCalls   *bool                   `json:"parallel_tool_calls,omitempty"`
	Prediction          *PredictionObject       `json:"prediction,omitempty"`
	PresencePenalty     *float64                `json:"presence_penalty,omitempty"`
	PromptCacheKey      *string                 `json:"prompt_cache_key,omitempty"`
	ReasoningEffort     *string                 `json:"reasoning_effort,omitempty"` // Currently supported values are low, medium, and high
	ResponseFormat      *ResponseFormat         `json:"response_format,omitempty"`
	SafetyIdentifier    *string                 `json:"safety_identifier,omitempty"`
	Seed                *int                    `json:"seed,omitempty"`
	ServiceTier         *string                 `json:"service_tier,omitempty"` // Can be "auto", "default", "flex"
	Stop                *json.RawMessage        `json:"stop,omitempty"`         // string or []string
	Store               *bool                   `json:"store,omitempty"`
	Stream              *bool                   `json:"stream,omitempty"`
	StreamOptions       *StreamOptions          `json:"stream_options,omitempty"`
	Temperature         *float64                `json:"temperature,omitempty"`
	ToolChoice          *json.RawMessage        `json:"tool_choice,omitempty"` // string or ToolChoiceObject
	Tools               []Tool                  `json:"tools,omitempty"`
	TopLogProbs         *int                    `json:"top_logprobs,omitempty"`
	TopP                *float64                `json:"top_p,omitempty"`
	WebSearchOptions    *WebSearchOptions       `json:"web_search_options,omitempty"`
}

// ChatCompletionMessage represents a single message in the conversation.
type ChatCompletionMessage struct {
	Role       string      `json:"role"`    // "system", "user", "assistant", "developer", "tool"
	Content    interface{} `json:"content"` // string or []ContentPart
	Name       *string     `json:"name,omitempty"`
	Audio      *AudioData  `json:"audio,omitempty"`        // For previous assistant audio response
	Refusal    *string     `json:"refusal,omitempty"`      // For assistant refusal
	ToolCallID *string     `json:"tool_call_id,omitempty"` // Required for tool messages
	ToolCalls  []ToolCall  `json:"tool_calls,omitempty"`   // For assistant tool calls
}

// ContentPart represents a part of the message content (text, image, audio, file).
// You might need to implement custom marshaling/unmarshaling for this.
// type ContentPart interface{} // Could be TextContentPart, ImageContentPart, etc.

// TextContentPart represents textual content within a message.
type TextContentPart struct {
	Type string `json:"type"` // "text"
	Text string `json:"text"`
}

// AudioOutputConfig represents parameters for audio output.
type AudioOutputConfig struct {
	Format string `json:"format"` // wav, mp3, flac, opus, or pcm16.
	Voice  string `json:"voice"`  // alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, and shimmer.
}

// AudioData represents data about a previous audio response (placeholder).
type AudioData struct {
	ID string `json:"id"`
	// Add other fields as needed from the documentation
}

// Tool represents a function the model can call.
type Tool struct {
	Type     string             `json:"type"` // Currently, only "function" is supported
	Function FunctionDefinition `json:"function"`
}

// FunctionDefinition defines a function available for the model to call.
type FunctionDefinition struct {
	Name        string      `json:"name"`
	Description *string     `json:"description,omitempty"`
	Parameters  interface{} `json:"parameters,omitempty"` // JSON Schema object
	Strict      *bool       `json:"strict,omitempty"`
}

// ToolCall represents a call to a tool/function generated by the model.
type ToolCall struct {
	ID       string       `json:"id"`
	Type     string       `json:"type"` // Currently, only "function" is supported
	Function FunctionCall `json:"function"`
}

// FunctionCall represents the name and arguments of a function call (generated or for tool messages).
type FunctionCall struct {
	Name      string `json:"name"`
	Arguments string `json:"arguments"` // JSON formatted string
}

type PredictionObject struct {
	Content struct {
		Text string `json:"text"`
		Type string `json:"type"`
	} `json:"content"`
	Type string `json:"type"`
}

// StreamOptions represents options for streaming responses.
type StreamOptions struct {
	// Add fields as defined in the API docs if needed
	IncludeUsage *bool `json:"include_usage,omitempty"`
}

// WebSearchOptions represents options for the web search tool.
type WebSearchOptions struct {
	SearchContextSize *string       `json:"search_context_size,omitempty"` // "low", "medium", "high"
	UserLocation      *UserLocation `json:"user_location,omitempty"`
}

// UserLocation represents approximate location for the search.
type UserLocation struct {
	Approximate Approximate `json:"approximate"`
	Type        string      `json:"type"` // Always "approximate"
}

// Approximate represents the approximate location parameters.
type Approximate struct {
	// Define fields for approximate location (e.g., city, country, coordinates)
	// The API docs don't specify the exact structure, so you'll need to adapt this.
	City     *string `json:"city,omitempty"`
	Country  *string `json:"country,omitempty"`
	Region   *string `json:"region,omitempty"`
	Timezone *string `json:"timezone,omitempty"`
}

type ResponseFormat struct {
	Type       string `json:"type"` // Can be "json_object" or "json_schema"
	JSONSchema *struct {
		Name        string      `json:"name"`
		Description *string     `json:"description,omitempty"`
		Schema      interface{} `json:"schema,omitempty"`
		Strict      *bool       `json:"strict,omitempty"`
	} `json:"json_schema,omitempty"`
}

type ToolChoiceObject struct {
	Function struct {
		Name string `json:"name"`
	} `json:"function"`
	Type string `json:"type"`
}
